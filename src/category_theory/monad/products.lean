/-
Copyright (c) 2021 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta
-/
import category_theory.over
import category_theory.limits.preserves.basic
import category_theory.limits.creates
import category_theory.limits.shapes.binary_products
import category_theory.monad.algebra

noncomputable theory

universes v u -- declare the `v`'s first; see `category_theory.category` for an explanation

namespace category_theory
open category limits

variables {C : Type u} [category.{v} C] (X : C)

section

open comonad
variable [has_binary_products C]

@[simps]
instance : comonad (prod.functor.obj X) :=
{ Œµ := { app := Œª Y, limits.prod.snd },
  Œ¥ := { app := Œª Y, prod.lift limits.prod.fst (ùüô _) } }

@[simps]
def coalgebra_to_over :
  coalgebra (prod.functor.obj X) ‚•§ over X :=
{ obj := Œª A, over.mk (A.a ‚â´ limits.prod.fst),
  map := Œª A‚ÇÅ A‚ÇÇ f, over.hom_mk f.f (by simp [‚Üêf.h_assoc]) }

@[simps]
def over_to_coalgebra :
  over X ‚•§ coalgebra (prod.functor.obj X) :=
{ obj := Œª f, { A := f.left, a := prod.lift f.hom (ùüô _) },
  map := Œª f‚ÇÅ f‚ÇÇ g, { f := g.left } }

@[simps {rhs_md := semireducible}]
def coalgebra_equiv_over :
  coalgebra (prod.functor.obj X) ‚âå over X :=
{ functor := coalgebra_to_over X,
  inverse := over_to_coalgebra X,
  unit_iso := nat_iso.of_components
                (Œª A, coalgebra.mk_iso (iso.refl _)
                        (prod.hom_ext (by { dsimp, simp }) (by { dsimp, simpa using A.counit })))
              (Œª A‚ÇÅ A‚ÇÇ f, by { ext, simp }),
  counit_iso := nat_iso.of_components (Œª f, over.iso_mk (iso.refl _)) (Œª f g k, by tidy) }.

end

section

open monad
variable [has_binary_coproducts C]

@[simps]
instance : monad (coprod.functor.obj X) :=
{ Œ∑ := { app := Œª Y, coprod.inr },
  Œº := { app := Œª Y, coprod.desc coprod.inl (ùüô _) } }

@[simps]
def algebra_to_under :
  monad.algebra (coprod.functor.obj X) ‚•§ under X :=
{ obj := Œª A, under.mk (coprod.inl ‚â´ A.a),
  map := Œª A‚ÇÅ A‚ÇÇ f, under.hom_mk f.f (by { dsimp, simp [‚Üêf.h] }) }

@[simps]
def under_to_algebra :
  under X ‚•§ monad.algebra (coprod.functor.obj X) :=
{ obj := Œª f, { A := f.right, a := coprod.desc f.hom (ùüô _) },
  map := Œª f‚ÇÅ f‚ÇÇ g, { f := g.right } }

@[simps {rhs_md := semireducible}]
def algebra_equiv_under :
  monad.algebra (coprod.functor.obj X) ‚âå under X :=
{ functor := algebra_to_under X,
  inverse := under_to_algebra X,
  unit_iso := nat_iso.of_components
                 (Œª A, monad.algebra.mk_iso (iso.refl _)
                         (coprod.hom_ext (by tidy) (by { dsimp, simpa using A.unit.symm })))
                 (Œª A‚ÇÅ A‚ÇÇ f, by { ext, simp }),
  counit_iso := nat_iso.of_components (Œª f, under.iso_mk (iso.refl _) (by tidy)) (Œª f g k, by tidy) }.

end

-- def star [has_binary_products C] : C ‚•§ over X :=
-- cofree _ ‚ãô coalgebra_to_over X

-- lemma forget_iso [has_binary_products C] : over_to_coalgebra X ‚ãô forget _ = over.forget X :=
-- rfl

-- def forget_adj_star [has_binary_products C] : over.forget X ‚ä£ star X :=
-- (coalgebra_equiv_over X).symm.to_adjunction.comp _ _ (adj _)

end category_theory
